import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.StdStats;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;

import java.util.Arrays;

import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;

public class Percolation {
private int n;
private WeightedQuickUnionUF wquf;
private int[] openSites;

	public static void main(String[] args) {
		Percolation p = new Percolation(3);
	    System.out.println("hello");
	    
//	    StdOut.println(p.isVirtualTop(2));
//	    StdOut.println(p.isVirtualBottom(8));
//	    StdOut.println(p.isLeftMost(7));
//	    StdOut.println(p.isRightMost(3));
	    p.open(1, 1);
	    p.open(1, 2);
	    p.open(3, 2);
	    p.open(2, 2);
	    p.open(2, 3);
	    StdOut.println(Arrays.toString(p.openSites));
	    
	    StdOut.println("connections ----");
	    StdOut.println(p.wquf.connected(0, 1));
	    StdOut.println(p.wquf.connected(1, 4));
	    StdOut.println(p.wquf.connected(4, 7));
	    StdOut.println(p.wquf.connected(0, 7));
	    StdOut.println(p.wquf.connected(7, 9));
	    StdOut.println("find ----");
	    StdOut.println(p.wquf.find(7));
	    StdOut.println(p.isFull(3, 2));
	    StdOut.println("--- percolates");
	    StdOut.println(p.percolates());
	}
	
//create n-by-n grid, with all sites blocked
   public Percolation(int n) {  
	   if(n <= 0) throw new IllegalArgumentException("n is less than 0!");
	   this.n = n;
	   this.wquf = new WeightedQuickUnionUF(this.n*this.n+1);
	   this.openSites = new int[this.n*this.n+1];
	   this.openSites[this.n*this.n]=1;//virtual bottom
   }
   
// open site (row, col) if it is not open already
   public void open(int row, int col){
	   StdOut.println("openning --");
	   StdOut.println(row);
	   StdOut.println(col);
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	   this.openSites[num-1] = 1;  
	   
	   //check if top, left, bottom, and right are open
	   if(!this.isVirtualTop(num)){//check top
		   if(this.isOpen(row-1, col)){
			   int topNum = this.rowColTo1D(row-1, col);
			   if(!this.wquf.connected(num-1, topNum-1)){
				   this.wquf.union(num-1, topNum-1);
			   }
		   }
	   }
	   if(!this.isVirtualBottom(num)){//check bottom
		   if(this.isOpen(row+1, col)){
			   int bottomNum = this.rowColTo1D(row+1, col);
			   if(!this.wquf.connected(num-1, bottomNum-1)){
				   this.wquf.union(num-1, bottomNum-1);
			   }
		   }
	   }
	   StdOut.println("is leftmost ---");
	   StdOut.println(this.isLeftMost(num));
	   if(!this.isLeftMost(num)){//check left
		   StdOut.println("check if left if open ---");
		   StdOut.println(this.isOpen(row, col-1));
		   if(this.isOpen(row, col-1)){
			   int leftNum = this.rowColTo1D(row, col-1);
			   StdOut.println("leftnum ---");
			   StdOut.println(leftNum-1);
			   StdOut.println("connected ---");
			   StdOut.println(this.wquf.connected(num-1, leftNum-1));
			   if(!this.wquf.connected(num-1, leftNum-1)){
				   this.wquf.union(num-1, leftNum-1);
			   }
		   }
	   }
	   StdOut.println(this.isRightMost(num));
	   if(!this.isRightMost(num)){//check right
		   StdOut.println("checking is has neightbors");
		   StdOut.println(this.isOpen(row, col+1));
		   if(this.isOpen(row, col+1)){
			   int rightNum = this.rowColTo1D(row, col+1);
			   if(!this.wquf.connected(num-1, rightNum-1)){
				   this.wquf.union(num-1, rightNum-1);
			   }
		   }
	   }
	   StdOut.println("open");
   }
// is site (row, col) open?
   public boolean isOpen(int row, int col) {
//	   StdOut.println("is open ---");
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	   if(this.openSites[num-1]==1){
		   return true;
	   }
       return false;
   }
// is site (row, col) full?
   public boolean isFull(int row, int col)  {
	   StdOut.println("is full ----");
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	   StdOut.println(num);
	  //check if it is connected
	   int rootNum = this.wquf.find(num-1);
	   StdOut.println(rootNum);
	   if(this.isVirtualTop(rootNum)){
		   return true;
	   }
       return false;
   }
   
// does the system percolate?
   public boolean percolates() {
//	   int rootNum = this.wquf.find(this.n*this.n);
//	   StdOut.println(rootNum);
//	   if(this.isVirtualTop(rootNum)){
//		   return true;
//	   }
//       return false;
	   return this.isFull(this.n+1, 1);
   }
   
   private boolean isVirtualTop(int x){
	   this.validSquareIndex(x);
	   if(x <= this.n){
		   return true;
	   }
	   return false;
   }
   
   private boolean isVirtualBottom(int x){
	   this.validSquareIndex(x);
	   if(x >= (this.n*(this.n-1))){
		   this.wquf.union(x-1, this.n*this.n);//unite with virtual bottom
		   return true;
	   }
	   return false;
   }
   
   private boolean isLeftMost(int x){
	   this.validSquareIndex(x);
	   if(x==1 || x % this.n ==1){
		   return true;
	   }
	   return false;
   }
   
   private boolean isRightMost(int x){
	   this.validSquareIndex(x);
	   if(x % this.n  == 0){
		   return true;
	   }
	   return false;
   }
   
   private void validIndex(int index){
	   if (index <= 0 || index > this.n) throw new IndexOutOfBoundsException("row index i out of bounds");
   }
   
   private void validSquareIndex(int index){
	   if (index <= 0 || index > (this.n*this.n+1)) throw new IndexOutOfBoundsException("row index i out of bounds");
   }
   
   private int rowColTo1D(int row, int col){
	   int id = this.n*(row-1)+col;
//	   System.out.println("rowColTo1D");
//	   System.out.println(id);
	   return id;
   }
   
}