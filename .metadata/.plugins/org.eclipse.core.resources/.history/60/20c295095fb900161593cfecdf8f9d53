import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.StdStats;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;

public class Percolation {
private int n;
private WeightedQuickUnionUF wquf;
private int[] openSites;

	public static void main(String[] args) {
		Percolation p = new Percolation(3);
	    System.out.println("hello");
	    StdOut.println(p.isVirtualTop(2));
	    StdOut.println(p.isVirtualBottom(8));
	    StdOut.println(p.isLeftMost(67));
	    StdOut.println(p.isRightMost(3));
	    p.open(1, 1);
	    p.open(1, 2);
	    p.open(3, 2);
	    p.open(2, 2);
	    p.open(2, 3);
	    
	    StdOut.println("connections ----");
	    StdOut.println(p.wquf.connected(5, 8));
	    StdOut.println(p.wquf.connected(2, 5));
	    StdOut.println(p.wquf.connected(6, 8));
	    StdOut.println("find ----");
	    StdOut.println(p.wquf.find(6));
//	    p.wquf.union(1, 2);
//	    
//	    StdOut.println(p.wquf.connected(1,2));
	}
	
//create n-by-n grid, with all sites blocked
   public Percolation(int n) {  
	   if(n <= 0) throw new IllegalArgumentException("n is less than 0!");
	   this.n = n;
	   this.wquf = new WeightedQuickUnionUF(this.n*this.n);
	   this.openSites = new int[this.n*this.n];
   }
   
// open site (row, col) if it is not open already
   public void open(int row, int col){
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	   this.openSites[num-1] = 1;  
	   
	   //check if top, left, bottom, and right are open
	   if(!this.isVirtualTop(num)){//check top
		   if(this.isOpen(row-1, col)){
			   int topNum = this.rowColTo1D(row-1, col);
			   if(!this.wquf.connected(num, topNum)){
				   this.wquf.union(num, topNum);
			   }
		   }
	   }
	   if(!this.isVirtualBottom(num)){//check bottom
		   if(this.isOpen(row+1, col)){
			   int bottomNum = this.rowColTo1D(row+1, col);
			   if(!this.wquf.connected(num, bottomNum)){
				   this.wquf.union(num, bottomNum);
			   }
		   }
	   }
	   if(!this.isLeftMost(num)){//check left
		   if(this.isOpen(row, col-1)){
			   int leftNum = this.rowColTo1D(row, col-1);
			   if(!this.wquf.connected(num, leftNum)){
				   this.wquf.union(num, leftNum);
			   }
		   }
	   }
	   if(!this.isRightMost(num)){//check left
		   if(this.isOpen(row, col+1)){
			   int rightNum = this.rowColTo1D(row, col+1);
			   if(!this.wquf.connected(num, rightNum)){
				   this.wquf.union(num, rightNum);
			   }
		   }
	   }
	   StdOut.println("open");
   }
// is site (row, col) open?
   public boolean isOpen(int row, int col) {
	   StdOut.println("is open ---");
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	   if(this.openSites[num-1]==1){
		   return true;
	   }
       return false;
   }
// is site (row, col) full?
   public boolean isFull(int row, int col)  {
	   this.validIndex(row);
	   this.validIndex(col);
	   int num = this.rowColTo1D(row, col);
	  //check if it is connected
//	   this.wquf.connected(row, )
       return false;
   }
   
// does the system percolate?
   public boolean percolates() {
	   
       return false;
   }
   
   private boolean isVirtualTop(int x){
	   if(x <= this.n){
		   return true;
	   }
	   return false;
   }
   
   private boolean isVirtualBottom(int x){
	   if(x >= (this.n*(this.n-1))){
		   return true;
	   }
	   return false;
   }
   
   private boolean isLeftMost(int x){
	   if(x==1 || x % this.n ==1){
		   return true;
	   }
	   return false;
   }
   
   private boolean isRightMost(int x){
	   if(x % this.n  == 0){
		   return true;
	   }
	   return false;
   }
   
   private void validIndex(int index){
	   if (index <= 0 || index > n) throw new IndexOutOfBoundsException("row index i out of bounds");
   }
   
   private int rowColTo1D(int row, int col){
	   int id = this.n*(row-1)+col;
//	   System.out.println("rowColTo1D");
//	   System.out.println(id);
	   return id;
   }
   
}